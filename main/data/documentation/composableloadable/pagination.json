{"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"identifier":{"url":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/Pagination","interfaceLanguage":"swift"},"metadata":{"modules":[{"name":"ComposableLoadable"}],"role":"article","roleHeading":"Article","title":"Pagination"},"kind":"article","primaryContentSections":[{"content":[{"anchor":"Overview","level":2,"text":"Overview","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Most applications which make use of an API to load a set of items because it cannot return all available items in a single request. To load more items, typically the application makes another request using a “pagination cursor”. This can go on indefinitely until all of the items have been loaded, and the API returns a nil pagination cursor.","type":"text"}]},{"inlineContent":[{"text":"To that end this library contains a TCA compatible feature to support “infinite” scrolling and paginating items.","type":"text"}],"type":"paragraph"},{"anchor":"Basics","level":3,"text":"Basics","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"For example lets says that you get a list of messages from an API, something like:","type":"text"}]},{"type":"codeListing","syntax":"json","code":["{","  \"messages\": [","    \/* etc *\/","  ],","  \"nextPage\": \"<next-page-of-messages>\"","}"]},{"inlineContent":[{"type":"text","text":"You can get the next page of messages, by sending the value for "},{"code":"nextPage","type":"codeVoice"},{"type":"text","text":" as a query parameter in a subsequent request."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By combining "},{"type":"codeVoice","code":"LoadableState"},{"type":"text","text":" and "},{"code":"PaginationFeature","type":"codeVoice"},{"type":"text","text":" from this library, we can write a feature like this:"}]},{"syntax":"swift","type":"codeListing","code":["struct Message: Identifiable {","  var id: String","}","@Reducer","struct MessagesFeature {","  struct State {","    \/\/ Wrap PaginationFeature state with LoadableState","    @LoadableStateWith<MessageRequest, PaginationFeature<Message>.State> var messages","  }","  enum Action {","    \/\/ The corresponding messages action","    case messages(","      \/\/ is a Loading Action","      LoadingAction<","        \/\/ generic over the kind of request sent to the `load` closure","        MessageRequest,","        \/\/ and the state\/action types","        PaginationFeature<Message>.State,","        PaginationFeature<Message>.Action","      >","    )","  }","  @Dependency(\\.api.loadMessages) var loadMessages","  var body: some ReducerOf<Self> {","    Reduce { state, action in","      \/\/ etc","      return .none","    }","    .loadable(\\.$messages, action: \\.messages) {","      PaginationFeature<Messages> { pageRequest in","        let response = try await loadMessages(cursor: pageRequest.cursor)","        return Page(","          next: response.nextPage,","          elements: response.messages","        )","      }","    } load: { request, state in","      let response = try await loadMessages()","      guard let firstMessage = response.messages.first else {","        fatalError(\"Handle no-results case\")","      }","      return PaginationFeature.State(","        selection: firstMessage.id,","        next: response.nextPage,","        elements: response.messages","      )","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"text":"In the above example, we ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"compose"}]},{"text":" ","type":"text"},{"code":"PaginationFeature.State","type":"codeVoice"},{"type":"text","text":" inside the application feature. "},{"type":"codeVoice","code":"PaginationFeature"},{"type":"text","text":" is generic of the kind of object which is to be paginated, so "},{"type":"codeVoice","code":"Message"},{"text":" in this example.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Because we need to also fetch the initial page of messages without any pagination cursors, we "},{"inlineContent":[{"type":"text","text":"wrap"}],"type":"emphasis"},{"text":" the ","type":"text"},{"type":"codeVoice","code":"PaginationFeature<Message>.State"},{"text":" with ","type":"text"},{"type":"codeVoice","code":"@LoadableState"},{"type":"text","text":". So this means that the "},{"code":".messages","type":"codeVoice"},{"text":" property itself is an optional, because initially it is in a ","type":"text"},{"code":".pending","type":"codeVoice"},{"text":" state.","type":"text"}],"type":"paragraph"},{"text":"Initial Load","type":"heading","level":3,"anchor":"Initial-Load"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the feature performs the initial "},{"code":".load","type":"codeVoice"},{"text":", the closure calls the API, and constructs ","type":"text"},{"code":"PaginationFeature.State","type":"codeVoice"},{"text":" from the response. In addition to the array of elements returned, the state value accepts ","type":"text"},{"code":"previous","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"next","type":"codeVoice"},{"type":"text","text":" pagination cursors. Here we define “next” to mean the values in the array which would be sorted after the current page of elements. If you API supports bi-directional pagination, the “previous” cursor is for those before the responses elements, however this value defaults to "},{"type":"codeVoice","code":"nil"},{"text":".","type":"text"}]},{"level":3,"text":"Selection","type":"heading","anchor":"Selection"},{"inlineContent":[{"type":"text","text":"The non-optional "},{"type":"codeVoice","code":"selection"},{"type":"text","text":" property can be used to track which element (across all pages) is currently selected. Because this is not and optional value, it might be necessary to consider how to handle the “empty result” edge case. A good idea would be to have a separate enum based feature for the "},{"type":"codeVoice","code":"ResultsFeature"},{"type":"text","text":" which includes a case for "},{"code":".noResults","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"heading","level":3,"text":"Pagination Context","anchor":"Pagination-Context"},{"inlineContent":[{"type":"text","text":"In some cases, it might be desirable to associate some additional metadata alongside your results. For example, perhaps the API also requires a “result-set-identifier”, or it’s necessary to keep hold of the total number of result elements. This is data which does not change or require mutation when performing pagination. In which case, create a specialised struct, which should conform to "},{"identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationContext","type":"reference","isActive":true},{"type":"text","text":" protocol, and set it as the "},{"type":"codeVoice","code":"context"},{"type":"text","text":" property."}],"type":"paragraph"},{"text":"Pagination","level":2,"anchor":"Pagination","type":"heading"},{"inlineContent":[{"text":"To load another page or to change the selection, use the actions available via ","type":"text"},{"code":"PaginationFeature.Action","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"level":3,"text":"Pagination Direction","type":"heading","anchor":"Pagination-Direction"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationDirection"},{"type":"text","text":" enum has four cases, "},{"code":".top","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":".bottom"},{"text":" for paging while vertically scrolling. And ","type":"text"},{"type":"codeVoice","code":".leading"},{"type":"text","text":", "},{"code":".trailing","type":"codeVoice"},{"type":"text","text":" to enable “horizontal” paging, which will update the selection and also fetch a new page. The directions, "},{"type":"codeVoice","code":".top"},{"text":" and ","type":"text"},{"type":"codeVoice","code":".leading"},{"type":"text","text":" both evaluate to showing or fetching elements which are before the current selection, while "},{"type":"codeVoice","code":".bottom"},{"text":" and ","type":"text"},{"code":".trailing","type":"codeVoice"},{"type":"text","text":" show elements which are after the current selection. In other words, "},{"code":".top","type":"codeVoice"},{"type":"text","text":" would prepend new elements to the list, and "},{"code":".bottom","type":"codeVoice"},{"type":"text","text":" will append new elements."}]},{"anchor":"Load-More","text":"Load More","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationLoadMore","isActive":true},{"type":"text","text":" is a SwiftUI view which can be placed in a scroll view to support infinite scrolling. If using a SwiftUI List or a ScrollView, we would expect to place a "},{"code":"ForEach","type":"codeVoice"},{"type":"text","text":" view followed by a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationLoadMore"},{"text":" view, to trigger loading of more elements.","type":"text"}]}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable"]]},"variants":[{"paths":["\/documentation\/composableloadable\/pagination"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"text":"When an API supports ","type":"text"},{"inlineContent":[{"text":"pagination","type":"text"}],"type":"emphasis"},{"text":", we mean that its response is a subset of items, but with a cursor to load the next “page” of items.","type":"text"}],"references":{"doc://ComposableLoadable/documentation/ComposableLoadable/PaginationDirection":{"title":"PaginationDirection","abstract":[{"text":"The direction of selection\/pagination","type":"text"}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PaginationDirection","kind":"identifier"}],"navigatorTitle":[{"text":"PaginationDirection","kind":"identifier"}],"url":"\/documentation\/composableloadable\/paginationdirection","kind":"symbol","type":"topic","role":"symbol","identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationDirection"},"https://github.com/pointfreeco/swift-composable-architecture":{"title":"The Composable Architecture","type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture","titleInlineContent":[{"text":"The Composable Architecture","type":"text"}],"url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture"},"doc://ComposableLoadable/documentation/ComposableLoadable":{"role":"collection","url":"\/documentation\/composableloadable","abstract":[{"text":"A micro-library to provide a “loading” capability to projects built with ","type":"text"},{"type":"reference","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture","isActive":true},{"type":"text","text":" (TCA)."}],"title":"ComposableLoadable","identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable","kind":"symbol","type":"topic"},"doc://ComposableLoadable/documentation/ComposableLoadable/PaginationContext":{"identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationContext","url":"\/documentation\/composableloadable\/paginationcontext","title":"PaginationContext","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PaginationContext"}],"role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"PaginationContext","kind":"identifier"}],"abstract":[{"code":"PaginationContext","type":"codeVoice"},{"text":" allows framework consumers to associate","type":"text"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"any"}]},{"text":" additional information which might be required for pagination.","type":"text"}],"kind":"symbol"},"doc://ComposableLoadable/documentation/ComposableLoadable/PaginationLoadMore":{"navigatorTitle":[{"kind":"identifier","text":"PaginationLoadMore"}],"role":"symbol","url":"\/documentation\/composableloadable\/paginationloadmore","abstract":[{"type":"text","text":"Trigger loading a new page when the view appears"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"PaginationLoadMore"}],"title":"PaginationLoadMore","identifier":"doc:\/\/ComposableLoadable\/documentation\/ComposableLoadable\/PaginationLoadMore","type":"topic","kind":"symbol"}}}